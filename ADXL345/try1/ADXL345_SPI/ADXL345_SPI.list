				;file C:\Users\IIIT\Desktop\ADXL345\try1\ADXL345_SPI\ADXL345_SPI.c
				;1	#include <HT66F70A.h>
				;2	
				;3	#define	DATA_BUS _pg
				;4	#define RS  _ph0
				;5	#define RW  _ph1
				;6	#define EN  _ph2
				;7	
				;8	#define SDO _pa5	//				;9	#define SDI _pa6	//				;10	#define SCK _pa7
				;11	#define CS  _pb5
				;12	
				;13	#define SDOC _pac5	//				;14	#define SDIC _pac6
				;15	#define SCKC _pac7
				;16	#define CSC  _pbc5
				;17	
				;18	#define SDOPU _papu5	//				;19	#define SDIPU _papu6
				;20	#define SCKPU _papu7
				;21	#define CSPU  _pbpu5
				;22	
				;23	void Delay100us(short);	
				;24	void _SPI_CS(unsigned short);
				;25	void _SPI_SCL(unsigned short);
				;26	unsigned char ADXL345_SPI_Read(unsigned char);
				;27	void ADXL345_SPI_Write(unsigned char,unsigned char);
				;28	void LCD_Cmd(unsigned char data);
				;29	void LCD_Senddata(unsigned char data);
				;30	void LCD_Reset(void);
				;31	void PinSet(void);
				;32	void PrintLCD(unsigned char);
				;33	
				;34	int RawDataX[2],RawDataY[2],RawDataZ[2];
				;35	int* ptrRawData[] =
020A	00AF	mov     PHC, a
020B	00A9	mov     PGPU, a
020C	00AB	mov     PGC, a
020D	0000	nop
020E	0000	nop
020F	0000	nop
				;36	{&RawDataX[0],&RawDataX[1],&RawDataY[0],&RawDataY[1],&RawDataZ[0],&RawDataZ[1]};
				;37	int AccX,AccY,AccZ;
				;38	int* ptrAcc[] = {&AccX,&AccY,&AccZ};
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
0207	00B1	mov     INTC1, a
0208	00B3	mov     INTC3, a
0209	00AD	mov     PHPU, a
				;39	unsigned int deviceID;
				;40	short a,b,i;
				;41	unsigned int DATAX0;
				;42	unsigned int DATAX1;
				;43	unsigned int DATAY0;
				;44	unsigned int DATAY1;
				;45	unsigned int DATAZ0;
				;46	unsigned int DATAZ1;
				;47	
				;48	void main()
				;49	{
				@code .SECTION 'CODE'
				include HT66F70A.inc
0000	1F0B	clr     BP
0001	2802	jmp     begin_startup_value
				startupend3:
				@start .SECTION 'CODE'
003C	0F00	mov     a, 0H
003D	008B	mov     BP, a
003E	29BA	jmp     _main
				;50		PinSet();	//				_main:
				_main:
01BA	21A8	call    _PinSet
				;51		Delay100us(20);
01BB	0F14	mov     a, 14H
01BC	4085	mov     bLevel, a
01BD	5F06	clr     bLevel[1]
01BE	203F	call    _Delay100us
				;52		ADXL345_SPI_Write(0x31,0x0B); //01BF	0F0B	mov     a, BH
01C0	4087	mov     data, a
01C1	0F31	mov     a, 31H
01C2	2144	call    _ADXL345_SPI_Write
				;53		ADXL345_SPI_Write(0x2D,0x08); //01C3	0F08	mov     a, 8H
01C4	4087	mov     data, a
01C5	0F2D	mov     a, 2DH
01C6	2144	call    _ADXL345_SPI_Write
				;54		//ADXL345_SPI_Write(0x2c,0x0F);
				;55		
				;56		LCD_Reset();		//LCD01C7	2139	call    _LCD_Reset
				;57	  
				;58		while(1)
				;59		{
				;60			/*for(i=5;i>=0;i--)
				;61			{
				;62				*ptrRawData[i] = (int)ADXL345_SPI_Read(i+50);
				;63			}
				;64			for(i=0;i<3;i++)
				;65			{
				;66				*ptrAcc[i] = ((*ptrRawData[1+i*2]<<8)&0xFF00) | (*ptrRawData[0+i*2]&0xFF);
				;67				*ptrAcc[i] = *ptrAcc[i] * 4;
				;68			}
				;69			AccX = ((RawDataX[1]<<8)&0xFF00)|(RawDataX[0]&0xFF);
				;70			AccX = AccX*4;
				;71			AccY = ((RawDataY[1]<<8)&0xFF00)|(RawDataY[0]&0xFF);
				;72			AccY = AccY*4;
				;73			AccZ = ((RawDataZ[1]<<8)&0xFF00)|(RawDataZ[0]&0xFF);
				;74			AccZ = AccZ*4;*/
				;75			
				;76			AccX = (ADXL345_SPI_Read(0x33)&0xFF00) | (ADXL345_SPI_Read(0x32)&0xFF);
				_L25:
01C8	0F33	mov     a, 33H
01C9	20D7	call    _ADXL345_SPI_Read
01CA	0F32	mov     a, 32H
01CB	20D7	call    _ADXL345_SPI_Read
01CC	4081	mov     rb, a
01CD	5F02	clr     rc
				;77			AccX = AccX * 4;
01CE	340A	clr     C
01CF	5A01	rlca    rb
01D0	40A5	mov     AccX[0], a
01D1	5A02	rlca    rc
01D2	40A6	mov     AccX[1], a
01D3	340A	clr     C
01D4	5AA5	rlc     AccX[0]
01D5	5AA6	rlc     AccX[1]
				;78			AccY = (ADXL345_SPI_Read(0x35)&0xFF00) | (ADXL345_SPI_Read(0x34)&0xFF);
01D6	0F35	mov     a, 35H
01D7	20D7	call    _ADXL345_SPI_Read
01D8	0F34	mov     a, 34H
01D9	20D7	call    _ADXL345_SPI_Read
01DA	4081	mov     rb, a
01DB	5F02	clr     rc
				;79			AccY = AccY * 4;
01DC	340A	clr     C
01DD	5A01	rlca    rb
01DE	40A3	mov     AccY[0], a
01DF	5A02	rlca    rc
01E0	40A4	mov     AccY[1], a
01E1	340A	clr     C
01E2	5AA3	rlc     AccY[0]
01E3	5AA4	rlc     AccY[1]
				;80			AccZ = (ADXL345_SPI_Read(0x37)&0xFF00) | (ADXL345_SPI_Read(0x36)&0xFF);
01E4	0F37	mov     a, 37H
01E5	20D7	call    _ADXL345_SPI_Read
01E6	0F36	mov     a, 36H
01E7	20D7	call    _ADXL345_SPI_Read
01E8	4081	mov     rb, a
01E9	5F02	clr     rc
				;81			AccZ = AccZ * 4;
01EA	340A	clr     C
01EB	5A01	rlca    rb
01EC	40A1	mov     AccZ[0], a
01ED	5A02	rlca    rc
01EE	40A2	mov     AccZ[1], a
01EF	340A	clr     C
01F0	5AA1	rlc     AccZ[0]
01F1	5AA2	rlc     AccZ[1]
				;82			
				;83			/*AccX = ((int)ADXL345_SPI_Read(DATAX1)<<8)|(int)ADXL345_SPI_Read(DATAX0);
				;84			AccY = ((int)ADXL345_SPI_Read(DATAY1)<<8)|(int)ADXL345_SPI_Read(DATAY0);
				;85			AccZ = ((int)ADXL345_SPI_Read(DATAZ1)<<8)|(int)ADXL345_SPI_Read(DATAZ0);*/
				;86			/*Delay100us(200);
				;87			LCD_Cmd(0x80);  //				;88		 	PrintLCD(AccX);
				;89		  	Delay100us(200);
				;90		  	LCD_Cmd(0x86);	//				;91		  	PrintLCD(AccY);
				;92			Delay100us(200);
				;93			LCD_Cmd(0x8d);	//				;94		  	PrintLCD(AccZ);*/
				;95	
				;96			deviceID = (unsigned int)ADXL345_SPI_Read(0x00);
01F2	0F00	mov     a, 0H
01F3	20D7	call    _ADXL345_SPI_Read
01F4	4080	mov     ra, a
01F5	4700	mov     a, ra
01F6	40A7	mov     deviceID[0], a
01F7	5F28	clr     deviceID[1]
				;97			LCD_Cmd(0xc0);	//01F8	0FC0	mov     a, C0H
01F9	20B4	call    _LCD_Cmd
				;98		  	PrintLCD(deviceID);
01FA	4727	mov     a, deviceID[0]
01FB	207D	call    _PrintLCD
				;99		  	
				;100		  	/*DATAZ0 = (int)ADXL345_SPI_Read(0x36);
				;101			LCD_Cmd(0xc6);	//				;102		  	PrintLCD(DATAZ0);
				;103		  	
				;104		  	DATAZ1 = (int)ADXL345_SPI_Read(0x37);
				;105			LCD_Cmd(0xcd);	//				;106		  	PrintLCD(DATAZ1);*/
				;107		  	
				;108		  	Delay100us(100);
01FC	0F64	mov     a, 64H
01FD	4085	mov     bLevel, a
01FE	5F06	clr     bLevel[1]
01FF	203F	call    _Delay100us
0200	29C8	jmp     _L25
0201	2A01	jmp     $
				startup_value:
				@ROMDATA_BASE .SECTION 'CODE'
0202	0012	jmp     L0012
0203	008B	mov     BP, a
0204	00A5	mov     PFPU, a
0205	00A3	mov     PEC, a
0206	00A1	mov     PEPU, a
				;109		}
				;110	}
				;111	//////////////////////////////
				;112	///				;113	//////////////////////////////
				;114	void PinSet(void)
				;115	{
				;116		_wdtc = 0b10101111;//				_PinSet:
				_PinSet:
01A8	0FAF	mov     a, AFH
01A9	00BE	mov     WDTC, a
				;117		_cp0c = 0x00;	//01AA	1F46	clr     CP0C
				;118		_cp1c = 0x00;
01AB	1F47	clr     CP1C
				;119		_scomen = 0;
01AC	367F	clr     SCOMEN
				;120		_smod = 0xe0;//4MHz
01AD	0FE0	mov     a, E0H
01AE	00BA	mov     SMOD, a
				;121		
				;122		SDOC=0; 	SDIC=1; 	SCKC=0;	    CSC=0;//01AF	3693	clr     PAC5
01B0	3313	set     PAC6
01B1	3793	clr     PAC7
01B2	3697	clr     PBC5
				;123		_phc0 =0;   _phc1=0;    _phc2=0;    //01B3	342F	clr     PHC0
01B4	34AF	clr     PHC1
01B5	352F	clr     PHC2
				;124		SCK=0;	CS=1;     //01B6	3792	clr     PA7
01B7	3296	set     PB5
				;125		_pgc = 0x00;   
01B8	1F2B	clr     PGC
01B9	0003	ret
				;126	}
				;127	
				;128	
				;129	//////////////////////////////
				;130	/////////SPI				;131	//////////////////////////////
				;132	unsigned char ADXL345_SPI_Read(unsigned char Address)
				;133	{
				_ADXL345_SPI_Read:
				_ADXL345_SPI_Read:
00D7	4087	mov     Address[0], a
				;134	  unsigned char ReadData=0;
0110	5F08	clr     ReadData[0]
				;135	  unsigned char tempSDO;
				;136	  _SPI_CS(0);
00D8	5F05	clr     bLevel
00D9	5F06	clr     bLevel[1]
00DA	20CB	call    __SPI_CS
				;137	  a=7;
00DB	0F07	mov     a, 7H
00DC	409F	mov     a[0], a
00DD	5F20	clr     a[1]
				;138	  do{
				;139	    // F-Edge
				;140	    /*LCD_Cmd(0x80);
				;141	    PrintLCD(a);*/
				;142	    _SPI_SCL(1);
				L00DE:
00DE	0F01	mov     a, 1H
00DF	4085	mov     bLevel, a
00E0	5F06	clr     bLevel[1]
00E1	20C1	call    __SPI_SCL
				;143	    SDO = 0x1 & ((0x80 | Address) >> a);
00E2	4707	mov     a, Address[0]
00E3	4081	mov     rb, a
00E4	7381	set     rb.7
00E5	5F02	clr     rc
00E6	541F	inca    a[0]
00E7	28ED	jmp     L00ED
				L00E8:
00E8	340A	clr     C
00E9	7F82	sz      rc.7
00EA	300A	set     C
00EB	5B82	rrc     rc
00EC	5B81	rrc     rb
				L00ED:
00ED	1785	sdz     ACC
00EE	28E8	jmp     L00E8
00EF	0F01	mov     a, 1H
00F0	4681	andm    a, rb
00F1	5101	swapa   rb
00F2	1885	rl      ACC
00F3	0EE0	and     a, E0H
00F4	4081	mov     rb, a
00F5	3692	clr     PA5
00F6	4701	mov     a, rb
00F7	0592	orm     a, PA
				;144	    _SPI_SCL(0);
00F8	5F05	clr     bLevel
00F9	5F06	clr     bLevel[1]
00FA	20C1	call    __SPI_SCL
				;145	    --a;
00FB	0FFF	mov     a, FFH
00FC	431F	add     a, a[0]
00FD	4081	mov     rb, a
00FE	0FFF	mov     a, FFH
00FF	5320	adc     a, a[1]
0100	4082	mov     rc, a
0101	4701	mov     a, rb
0102	409F	mov     a[0], a
0103	4702	mov     a, rc
0104	40A0	mov     a[1], a
				;146	  }while(a!=0); 
0105	4701	mov     a, rb
0106	4502	or      a, rc
0107	390A	snz     Z
0108	28DE	jmp     L00DE
				;147	  //===========================
				;148	  _SPI_SCL(1);
0109	0F01	mov     a, 1H
010A	4085	mov     bLevel, a
010B	5F06	clr     bLevel[1]
010C	20C1	call    __SPI_SCL
				;149	  //===========================
				;150	  a=7;
010D	0F07	mov     a, 7H
010E	409F	mov     a[0], a
010F	5F20	clr     a[1]
				;151	  do{
				;152	    // R-Edge
				;153	    _SPI_SCL(0);
				L0111:
0111	5F05	clr     bLevel
0112	5F06	clr     bLevel[1]
0113	20C1	call    __SPI_SCL
				;154	    _SPI_SCL(1);
0114	0F01	mov     a, 1H
0115	4085	mov     bLevel, a
0116	5F06	clr     bLevel[1]
0117	20C1	call    __SPI_SCL
				;155	    tempSDO = SDI; // Read bit
0118	5F03	clr     rd
0119	3F12	sz      PA6
011A	5483	inc     rd
				;156	    ReadData |= tempSDO << a;
011B	471F	mov     a, a[0]
011C	4081	mov     rb, a
011D	4720	mov     a, a[1]
011E	4082	mov     rc, a
011F	5F04	clr     re
0120	5401	inca    rb
0121	2925	jmp     L0125
				L0122:
0122	340A	clr     C
0123	5A83	rlc     rd
0124	5A84	rlc     re
				L0125:
0125	1785	sdz     ACC
0126	2922	jmp     L0122
0127	4703	mov     a, rd
0128	4588	orm     a, ReadData[0]
				;157	  }while(a--!=0);
0129	0FFF	mov     a, FFH
012A	4301	add     a, rb
012B	409F	mov     a[0], a
012C	0FFF	mov     a, FFH
012D	5302	adc     a, rc
012E	40A0	mov     a[1], a
012F	4701	mov     a, rb
0130	4502	or      a, rc
0131	390A	snz     Z
0132	2911	jmp     L0111
				;158	 
				;159	  _SPI_CS(1);
0133	0F01	mov     a, 1H
0134	4085	mov     bLevel, a
0135	5F06	clr     bLevel[1]
0136	20CB	call    __SPI_CS
				;160	  return ReadData & 0xFF;
				;161	}
0137	4708	mov     a, ReadData[0]
0138	0003	ret
				;162	
				;163	//////////////////////////////
				;164	///LCD				;165	//////////////////////////////
				;166	void PrintLCD(unsigned char data)
				;167	{
				_PrintLCD:
				_PrintLCD:
007D	4080	mov     ra, a
007E	408A	mov     data[0], a
				;168		LCD_Senddata((data/100)%10+0x30);
007F	5F08	clr     Address
0080	4700	mov     a, ra
0081	4085	mov     bLevel, a
0082	0F64	mov     a, 64H
0083	4086	mov     bLevel[1], a
0084	2064	call    L0064
0085	4705	mov     a, bLevel
0086	4080	mov     ra, a
0087	5F08	clr     Address
0088	4700	mov     a, ra
0089	4085	mov     bLevel, a
008A	0F0A	mov     a, AH
008B	4086	mov     bLevel[1], a
008C	2064	call    L0064
008D	4707	mov     a, data
008E	4080	mov     ra, a
008F	0F30	mov     a, 30H
0090	4380	addm    a, ra
0091	4700	mov     a, ra
0092	2057	call    _LCD_Senddata
				;169		LCD_Senddata((data/10)%10+0x30);
0093	5F08	clr     Address
0094	470A	mov     a, data[0]
0095	4085	mov     bLevel, a
0096	0F0A	mov     a, AH
0097	4086	mov     bLevel[1], a
0098	2064	call    L0064
0099	4705	mov     a, bLevel
009A	4080	mov     ra, a
009B	5F08	clr     Address
009C	4700	mov     a, ra
009D	4085	mov     bLevel, a
009E	0F0A	mov     a, AH
009F	4086	mov     bLevel[1], a
00A0	2064	call    L0064
00A1	4707	mov     a, data
00A2	4080	mov     ra, a
00A3	0F30	mov     a, 30H
00A4	4380	addm    a, ra
00A5	4700	mov     a, ra
00A6	2057	call    _LCD_Senddata
				;170		LCD_Senddata((data/1)%10+0x30);
00A7	5F08	clr     Address
00A8	470A	mov     a, data[0]
00A9	4085	mov     bLevel, a
00AA	0F0A	mov     a, AH
00AB	4086	mov     bLevel[1], a
00AC	2064	call    L0064
00AD	4707	mov     a, data
00AE	4080	mov     ra, a
00AF	0F30	mov     a, 30H
00B0	4380	addm    a, ra
00B1	4700	mov     a, ra
00B2	2057	call    _LCD_Senddata
00B3	0003	ret
				;171	}
				;172	
				;173	//////////////////////////////
				;174	///Delay100us				;175	//////////////////////////////
				;176	void Delay100us(short del)						//				;177	{	unsigned short k,l;							//@fSYS=8MH,				_Delay100us:
				_Delay100us:
003F	4705	mov     a, del[0]
0040	4083	mov     rd, a
0041	4706	mov     a, del[1]
0042	4084	mov     re, a
				;178		for(k=0;k<del;k++)
0043	5F01	clr     rb
0044	5F02	clr     rc
				_L3:
0045	4701	mov     a, rb
0046	4203	sub     a, rd
0047	4702	mov     a, rc
0048	5204	sbc     a, re
0049	3F0A	sz      CZ
004A	2856	jmp     _L2
004B	5F00	clr     ra
0052	5481	inc     rb
0053	3D0A	sz      Z
0054	5482	inc     rc
0055	2845	jmp     _L3
				_L2:
0056	0003	ret
				;179			for(l=0;l<=25;l++)GCC_NOP();
				_L6:
004C	0000	nop
004D	5480	inc     ra
004E	4700	mov     a, ra
004F	0A1A	sub     a, 1AH
0050	390A	snz     Z
0051	284C	jmp     _L6
				;180	}	
				;181	
				;182	//////////////////////////////
				;183	///CS				;184	//////////////////////////////
				;185	void _SPI_CS(unsigned short isSelect)
				;186	{
				;187	    CS=isSelect;
				__SPI_CS:
				__SPI_CS:
00CB	4705	mov     a, isSelect[0]
00CC	0E01	and     a, 1H
00CD	4080	mov     ra, a
00CE	5100	swapa   ra
00CF	1885	rl      ACC
00D0	0EE0	and     a, E0H
00D1	4080	mov     ra, a
00D2	3696	clr     PB5
00D3	4700	mov     a, ra
00D4	0596	orm     a, PB
				;188	    GCC_NOP();
00D5	0000	nop
00D6	0003	ret
				;189	}
				;190	
				;191	//////////////////////////////
				;192	///SCL				;193	//////////////////////////////
				;194	void _SPI_SCL(unsigned short bLevel)
				;195	{
				;196	    SCK=bLevel;
				__SPI_SCL:
				__SPI_SCL:
00C1	4705	mov     a, bLevel[0]
00C2	4080	mov     ra, a
00C3	5B80	rrc     ra
00C4	5F00	clr     ra
00C5	5B80	rrc     ra
00C6	3792	clr     PA7
00C7	4700	mov     a, ra
00C8	0592	orm     a, PA
				;197	    GCC_NOP();
00C9	0000	nop
00CA	0003	ret
				;198	}
				;199	
				;200	//////////////////////////////
				;201	///SPI				;202	//////////////////////////////
				;203	void ADXL345_SPI_Write(unsigned char Address,unsigned char WriteData)
				;204	{
				_ADXL345_SPI_Write:
				_ADXL345_SPI_Write:
0144	4088	mov     Address[0], a
				;205	  _SPI_CS(0);
0145	5F05	clr     bLevel
0146	5F06	clr     bLevel[1]
0147	20CB	call    __SPI_CS
				;206	  b=7;
0148	0F07	mov     a, 7H
0149	409D	mov     b[0], a
014A	5F1E	clr     b[1]
				;207	  do{
				;208	    // F-Edge
				;209	    _SPI_SCL(1);
				L014B:
014B	0F01	mov     a, 1H
014C	4085	mov     bLevel, a
014D	5F06	clr     bLevel[1]
014E	20C1	call    __SPI_SCL
				;210	    SDO = 0x1 & ((0x7F & Address) >> b);
014F	4708	mov     a, Address[0]
0150	4081	mov     rb, a
0151	7781	clr     rb.7
0152	5F02	clr     rc
0153	541D	inca    b[0]
0154	295A	jmp     L015A
				L0155:
0155	340A	clr     C
0156	7F82	sz      rc.7
0157	300A	set     C
0158	5B82	rrc     rc
0159	5B81	rrc     rb
				L015A:
015A	1785	sdz     ACC
015B	2955	jmp     L0155
015C	0F01	mov     a, 1H
015D	4681	andm    a, rb
015E	5101	swapa   rb
015F	1885	rl      ACC
0160	0EE0	and     a, E0H
0161	4081	mov     rb, a
0162	3692	clr     PA5
0163	4701	mov     a, rb
0164	0592	orm     a, PA
				;211	    _SPI_SCL(0);
0165	5F05	clr     bLevel
0166	5F06	clr     bLevel[1]
0167	20C1	call    __SPI_SCL
				;212	    --b;
0168	0FFF	mov     a, FFH
0169	431D	add     a, b[0]
016A	4081	mov     rb, a
016B	0FFF	mov     a, FFH
016C	531E	adc     a, b[1]
016D	4082	mov     rc, a
016E	4701	mov     a, rb
016F	409D	mov     b[0], a
0170	4702	mov     a, rc
0171	409E	mov     b[1], a
				;213	  }while(b!=0);
0172	4701	mov     a, rb
0173	4502	or      a, rc
0174	390A	snz     Z
0175	294B	jmp     L014B
				;214	  
				;215	  b=7;
0176	0F07	mov     a, 7H
0177	409D	mov     b[0], a
0178	5F1E	clr     b[1]
				;216	  do{
				;217	    // F-Edge
				;218	    _SPI_SCL(1);
				L0179:
0179	0F01	mov     a, 1H
017A	4085	mov     bLevel, a
017B	5F06	clr     bLevel[1]
017C	20C1	call    __SPI_SCL
				;219	    SDO = 0x1 & ((WriteData) >> b);
017D	4707	mov     a, WriteData[0]
017E	4081	mov     rb, a
017F	5F02	clr     rc
0180	541D	inca    b[0]
0181	2987	jmp     L0187
				L0182:
0182	340A	clr     C
0183	7F82	sz      rc.7
0184	300A	set     C
0185	5B82	rrc     rc
0186	5B81	rrc     rb
				L0187:
0187	1785	sdz     ACC
0188	2982	jmp     L0182
0189	0F01	mov     a, 1H
018A	4681	andm    a, rb
018B	5101	swapa   rb
018C	1885	rl      ACC
018D	0EE0	and     a, E0H
018E	4081	mov     rb, a
018F	3692	clr     PA5
0190	4701	mov     a, rb
0191	0592	orm     a, PA
				;220	    _SPI_SCL(0);
0192	5F05	clr     bLevel
0193	5F06	clr     bLevel[1]
0194	20C1	call    __SPI_SCL
				;221	    --b;
0195	0FFF	mov     a, FFH
0196	431D	add     a, b[0]
0197	4081	mov     rb, a
0198	0FFF	mov     a, FFH
0199	531E	adc     a, b[1]
019A	4082	mov     rc, a
019B	4701	mov     a, rb
019C	409D	mov     b[0], a
019D	4702	mov     a, rc
019E	409E	mov     b[1], a
				;222	  }while(b!=0);
019F	4701	mov     a, rb
01A0	4502	or      a, rc
01A1	390A	snz     Z
01A2	2979	jmp     L0179
				;223	  _SPI_CS(1);
01A3	0F01	mov     a, 1H
01A4	4085	mov     bLevel, a
01A5	5F06	clr     bLevel[1]
01A6	20CB	call    __SPI_CS
01A7	0003	ret
				;224	}
				;225	
				;226	//---				;227	void LCD_Cmd(unsigned char data)
				;228	{
				_LCD_Cmd:
				_LCD_Cmd:
00B4	4080	mov     ra, a
00B5	4087	mov     data[0], a
				;229	    DATA_BUS = data;  //00B6	4700	mov     a, ra
00B7	00AA	mov     PG, a
				;230	    RS=0; RW=0; EN=1; //00B8	342E	clr     PH0
00B9	34AE	clr     PH1
00BA	312E	set     PH2
				;231	    Delay100us(20);
00BB	0F14	mov     a, 14H
00BC	4085	mov     bLevel, a
00BD	5F06	clr     bLevel[1]
00BE	203F	call    _Delay100us
				;232	    EN=0;           //00BF	352E	clr     PH2
00C0	0003	ret
				;233	}
				;234	//---				;235	void LCD_Senddata(unsigned char data)
				;236	{
				_LCD_Senddata:
				_LCD_Senddata:
0057	4080	mov     ra, a
0058	4087	mov     data[0], a
				;237	    DATA_BUS = data;  //0059	4700	mov     a, ra
005A	00AA	mov     PG, a
				;238	    RS=1; RW=0; EN=1; //005B	302E	set     PH0
005C	34AE	clr     PH1
005D	312E	set     PH2
				;239		Delay100us(20);
005E	0F14	mov     a, 14H
005F	4085	mov     bLevel, a
0060	5F06	clr     bLevel[1]
0061	203F	call    _Delay100us
				;240	    EN=0;           //0062	352E	clr     PH2
0063	0003	ret
				L0064:
0064	5F07	clr     data[0]
0065	0F08	mov     a, 8H
0066	4089	mov     Address[1], a
				L0067:
0067	340A	clr     C
0068	5A85	rlc     bLevel
0069	5A87	rlc     data[0]
006A	4707	mov     a, data[0]
006B	4206	sub     a, bLevel[1]
006C	380A	snz     C
006D	2872	jmp     L0072
006E	4707	mov     a, data[0]
006F	4206	sub     a, bLevel[1]
0070	4087	mov     data[0], a
0071	5485	inc     bLevel
				L0072:
0072	5789	sdz     Address[1]
0073	2867	jmp     L0067
0074	7C08	sz      Address.0
0075	4187	cpl     data[0]
0076	7C08	sz      Address.0
0077	5487	inc     data[0]
0078	7C88	sz      Address.1
0079	4185	cpl     bLevel
007A	7C88	sz      Address.1
007B	5485	inc     bLevel
007C	0003	ret
				;241	}
				;242	//---LCD				;243	void LCD_Reset(void)
				;244	{
				;245	    LCD_Cmd(0b00111000);//8bit				_LCD_Reset:
				_LCD_Reset:
0139	0F38	mov     a, 38H
013A	20B4	call    _LCD_Cmd
				;246	                        //bit4:DL=1,8bit				;247	                        //bit3:N=1,				;248	                        //bit2:F=0,5*7				;249	    LCD_Cmd(0b00001100);//013B	0F0C	mov     a, CH
013C	20B4	call    _LCD_Cmd
				;250	                        //bit2:D=1,				;251	                        //bit1:C=0,				;252	    LCD_Cmd(0b00000110);//013D	0F06	mov     a, 6H
013E	20B4	call    _LCD_Cmd
				;253	                        //bit1:I/D=1,				;254	                        //bit0:S=0,				;255	    LCD_Cmd(0b00000001); //013F	0F01	mov     a, 1H
0140	20B4	call    _LCD_Cmd
				;256	    LCD_Cmd(0b00000010); //0141	0F02	mov     a, 2H
0142	20B4	call    _LCD_Cmd
0143	0003	ret
				;257	}
				;file C:\Users\IIIT\Desktop\ADXL345\try1\ADXL345_SPI\startup1_l.asm
				;1	;;--------------------------------------------------------------;;
				;2	;;    This file is part of the Holtek C Compiler V3 package     ;;
				;3	;;    For the initialization of static linkage variables        ;;
				;4	;;    Copyright (C) 2017 Holtek Semiconductor Inc.              ;;
				;5	;;    Version: 1.07 (Above IDE3000 V7.94)                       ;;
				;6	;;    Date:    2017/03/06                                        ;;
				;7	;;--------------------------------------------------------------;;
				;8	
				;9	acc equ [05h]
				;10	tblp equ [07h]
				;11	tblh equ [08h]
				;12	;;tbhp equ [09h] 
				;13	r0 equ [00h]
				;14	mp0 equ [01h]
				;15	r1 equ [02h]
				;16	mp1l equ [03h]
				;17	mp1h equ [04h]
				;18	z equ [0ah].2
				;19	c equ [0ah].0
				;20	
				;21	ifndef tbhp
				;22	tbhp equ [09h]
				;23	endif
				;24	 
				;25	extern startup_value_1:near
				;26	
				;27	@start .section 'code'
				;28	begin_startup_value:
				;29	  mov a,low (offset startup_value_1) 
				begin_startup_value:
				@start .SECTION 'CODE'
				_main_startup1:
				@start .SECTION 'CODE'
0002	0F01	mov     a, 1H
				;30	  mov tblp,a
0003	0087	mov     TBLP, a
				;31	  mov a,high (offset startup_value_1) 
0004	0F02	mov     a, 2H
				;32	  mov tbhp,a
0005	0089	mov     TBHP, a
				;33	next_table:
				;34	  ;CLR WDT
				;35	  inc tblp
				next_table:
0006	1487	inc     TBLP
				;36	  sz z
0007	3D0A	sz      Z
				;37	  inc tbhp
0008	1489	inc     TBHP
				;38	ifdef USE_TABRDC
				;39	  tabrdc mp0
				;40	else
				;41	  tabrd mp0
0009	1D01	tabrd   MP0
				;42	endif
				;43	  sz mp0
000A	1081	sz      MP0
				;44	  jmp read_data
000B	280D	jmp     read_data
				;45	  jmp startupend1
000C	2822	jmp     startupend1
				;46	read_data:
				;47	  inc tblp
				read_data:
000D	1487	inc     TBLP
				;48	  sz z
000E	3D0A	sz      Z
				;49	  inc tbhp
000F	1489	inc     TBHP
				;50	ifdef USE_TABRDC
				;51	  tabrdc mp1l
				;52	else
				;53	  tabrd mp1l
0010	1D03	tabrd   MP1L
				;54	endif
				;55	  mov a,tblh
0011	0708	mov     a, TBLH
				;56	  mov mp1h,a
				L0012:
0012	0084	mov     MP1H, a
				;57	next_data:
				;58	  inc tblp
				next_data:
0013	1487	inc     TBLP
				;59	  sz z
0014	3D0A	sz      Z
				;60	  inc tbhp
0015	1489	inc     TBHP
				;61	ifdef USE_TABRDC
				;62	  tabrdc acc
				;63	else
				;64	  tabrd acc
0016	1D05	tabrd   ACC
				;65	endif
				;66	  mov r1,a
0017	0082	mov     [02H], a
				;67	  sdz mp0
0018	1781	sdz     MP0
				;68	  jmp $+2
0019	281B	jmp     L001B
				;69	  jmp next_table
001A	2806	jmp     next_table
				;70	  inc mp1l
				L001B:
001B	1483	inc     MP1L
				;71	  mov a,tblh
001C	0708	mov     a, TBLH
				;72	  mov r1,a
001D	0082	mov     [02H], a
				;73	  inc mp1l
001E	1483	inc     MP1L
				;74	  sdz mp0
001F	1781	sdz     MP0
				;75	  jmp next_data
0020	2813	jmp     next_data
				;76	  jmp next_table
0021	2806	jmp     next_table
				;77	
				;78	;end_startup_value:
				;79	
				;80	startupend1:
				;81	ifndef Disable_Bit_Initial
				;82		MOV A,high  bitdatasec1_start
				startupend1:
0022	0F00	mov     a, 0H
				;83		MOV mp1h,a
0023	0084	mov     MP1H, a
				;84		MOV A,offset bitdatasec1_end
0024	0F80	mov     a, 80H
				;85		mov mp1l,A
0025	0083	mov     MP1L, a
				;86		dec mp1l
0026	1583	dec     MP1L
				;87		clr z
0027	350A	clr     Z
				;88		sub a,offset bitdatasec1_start
0028	0A80	sub     a, 80H
				;89		sz z
0029	3D0A	sz      Z
				;90		jmp startupend2
002A	282F	jmp     startupend2
				;91	L0005:
				;92		set r1
				L0005:
002B	1F82	set     [02H]
				;93		dec mp1l
002C	1583	dec     MP1L
				;94		sdz  acc
002D	1785	sdz     ACC
				;95		jmp L0005
002E	282B	jmp     L0005
				;96	
				;97	startupend2:
				;98		MOV A,high  bitdatasec0_start
				startupend2:
002F	0F00	mov     a, 0H
				;99		MOV mp1h,a
0030	0084	mov     MP1H, a
				;100		MOV A,offset bitdatasec0_end
0031	0F80	mov     a, 80H
				;101		mov mp1l,A
0032	0083	mov     MP1L, a
				;102		dec mp1l
0033	1583	dec     MP1L
				;103		clr z
0034	350A	clr     Z
				;104		sub a,offset bitdatasec0_start
0035	0A80	sub     a, 80H
				;105		sz  z
0036	3D0A	sz      Z
				;106		jmp startupend3
0037	283C	jmp     startupend3
				;107	L0006:
				;108		clr r1
				L0006:
0038	1F02	clr     [02H]
				;109		dec mp1l
0039	1583	dec     MP1L
				;110		sdz  acc
003A	1785	sdz     ACC
				;111		jmp L0006
003B	2838	jmp     L0006
				;112	startupend3:
				;113	endif		
				;114	   
				;115	@ROMDATA_BASE .SECTION com_l 'CODE'  
				;116	startup_value:
				;117	;;linker range the initial value table here
				;118	
				;119	@BITDATASEC1 .SECTION com_l 'DATA'  
				;120	bitdatasec1_start:
				;121	
				;122	@BITDATASEC1 .SECTION com_e 'DATA'  
				;123	bitdatasec1_end:
				;124	
				;125	@BITDATASEC .SECTION com_l 'DATA'  
				;126	bitdatasec0_start:
				;127	
				;128	@BITDATASEC .SECTION com_e 'DATA'  
				;129	bitdatasec0_end:
				data .SECTION 'DATA'
				__pa DB DUP (?) ; __pa
				__pac DB DUP (?) ; __pac
				__pb DB DUP (?) ; __pb
				__pbc DB DUP (?) ; __pbc
				__pg DB DUP (?) ; __pg
				__pgc DB DUP (?) ; __pgc
				__ph DB DUP (?) ; __ph
				__phc DB DUP (?) ; __phc
				__smod DB DUP (?) ; __smod
				__wdtc DB DUP (?) ; __wdtc
				__cp0c DB DUP (?) ; __cp0c
				__cp1c DB DUP (?) ; __cp1c
				__scomc DB DUP (?) ; __scomc
				ra DB DUP (?)
				rb DB DUP (?)
				rc DB DUP (?)
				rd DB DUP (?)
				re DB DUP (?)
				bLevel DB 2 DUP (?) ; bLevel
				data DB DUP (?) ; data
				Address DB DUP (?) ; Address
				data DB DUP (?) ; data
				ptrAcc DB DUP (?) ; ptrAcc
				ptrRawData DB DUP (?) ; ptrRawData
				b DB 2 DUP (?) ; b
				a DB 2 DUP (?) ; a
				AccZ DB 2 DUP (?) ; AccZ
				AccY DB 2 DUP (?) ; AccY
				AccX DB 2 DUP (?) ; AccX
				deviceID DB 2 DUP (?) ; deviceID
				RawDataZ DB DUP (?) ; RawDataZ
				RawDataY DB DUP (?) ; RawDataY
				RawDataX DB DUP (?) ; RawDataX
				DATAZ1 DB 2 DUP (?) ; DATAZ1
				DATAZ0 DB 2 DUP (?) ; DATAZ0
				DATAY1 DB 2 DUP (?) ; DATAY1
				DATAY0 DB 2 DUP (?) ; DATAY0
				DATAX1 DB 2 DUP (?) ; DATAX1
				DATAX0 DB 2 DUP (?) ; DATAX0
				i DB 2 DUP (?) ; i
