				;file C:\Users\IIIT\Desktop\ADXL345\try1\ADXL345_SPI\ADXL345_SPI.c
				;1	#include <HT66F70A.h>
				;2	
				;3	#define	DATA_BUS _pg
				;4	#define RS  _ph0
				;5	#define RW  _ph1
				;6	#define EN  _ph2
				;7	
				;8	#define SDO _pa5	//				;9	#define SDI _pa6	//				;10	#define SCK _pa7
				;11	#define CS  _pb5
				;12	
				;13	#define SDOC _pac5	//				;14	#define SDIC _pac6
				;15	#define SCKC _pac7
				;16	#define CSC  _pbc5
				;17	
				;18	#define SDOPU _papu5	//				;19	#define SDIPU _papu6
				;20	#define SCKPU _papu7
				;21	#define CSPU  _pbpu5
				;22	
				;23	#define PAS2 _pas2	//pas 5 SDO
				;24	#define PAS3 _pas3	//pas 6 7 SDI SCL
				;25	#define PBS2 _pbs2	//pbs5 scs
				;26	
				;27	void Delay100us(short);	
				;28	void _SPI_CS(unsigned short);
				;29	void _SPI_SCL(unsigned short);
				;30	char ADXL345_SPI_Read(char);
				;31	void ADXL345_SPI_Write(char ,char);
				;32	void LCD_Cmd(unsigned char data);
				;33	void LCD_Senddata(unsigned char data);
				;34	void LCD_Reset(void);
				;35	void PinSet(void);
				;36	void PrintLCD(unsigned char);
				;37	int RawDataX[2],RawDataY[2],RawDataZ[2];
				;38	int* ptrRawData[] =
021B	0000	nop
021C	0000	nop
021D	0000	nop
021E	0000	nop
021F	0000	nop
0220	0000	nop
				;39	{&RawDataX[0],&RawDataX[1],&RawDataY[0],&RawDataY[1],&RawDataZ[0],&RawDataZ[1]};
				;40	int AccX,AccY,AccZ;
				;41	int* ptrAcc[] = {&AccX,&AccY,&AccZ};
0218	00B8	mov     MFI4, a
0219	00B2	mov     INTC2, a
021A	00B4	mov     MFI0, a
				;42	char deviceID;
				;43	short a,b,i;
				;44	char DATAX0 = 0x32;
				;45	char DATAX1 = 0x33;
				;46	char DATAY0 = 0x34;
				;47	char DATAY1 = 0x35;
				;48	char DATAZ0 = 0x36;
				;49	char DATAZ1 = 0x37;
				;50	
				;51	void main()
				;52	{
				@code .SECTION 'CODE'
				include HT66F70A.inc
0000	1F0B	clr     BP
0001	2802	jmp     begin_startup_value
				startupend3:
				@start .SECTION 'CODE'
003C	0F00	mov     a, 0H
003D	008B	mov     BP, a
003E	29B8	jmp     _main
				;53		PinSet();	//				_main:
				_main:
01B8	21A4	call    _PinSet
				;54		Delay100us(200);
01B9	0FC8	mov     a, C8H
01BA	4085	mov     bLevel, a
01BB	5F06	clr     bLevel[1]
01BC	203F	call    _Delay100us
				;55		ADXL345_SPI_Write(0x31,0x0B); //01BD	0F0B	mov     a, BH
01BE	4087	mov     data, a
01BF	0F31	mov     a, 31H
01C0	214A	call    _ADXL345_SPI_Write
				;56		ADXL345_SPI_Write(0x2D,0x08); //01C1	0F08	mov     a, 8H
01C2	4087	mov     data, a
01C3	0F2D	mov     a, 2DH
01C4	214A	call    _ADXL345_SPI_Write
				;57		//ADXL345_SPI_Write(0x2c, 0x0F);
				;58		
				;59		LCD_Reset();		//LCD01C5	213F	call    _LCD_Reset
				;60		LCD_Cmd(0xc0);  	//LCD01C6	0FC0	mov     a, C0H
01C7	2132	call    _LCD_Cmd
				;61	  
				;62		while(1)
				;63		{
				;64			for(i=5;i>=0;i--)
				_L29:
01C8	0F05	mov     a, 5H
01C9	40A9	mov     i[0], a
01CA	5F2A	clr     i[1]
				_L27:
01CB	4729	mov     a, i[0]
01CC	4081	mov     rb, a
01CD	472A	mov     a, i[1]
01CE	4082	mov     rc, a
01CF	7F82	sz      rc.7
01D0	29F6	jmp     _L30
01F1	0FFF	mov     a, FFH
01F2	43A9	addm    a, i[0]
01F3	0FFF	mov     a, FFH
01F4	53AA	adcm    a, i[1]
01F5	29CB	jmp     _L27
				;65			{
				;66				*ptrRawData[i] = ADXL345_SPI_Read(i+50);
01D1	340A	clr     C
01D2	5A01	rlca    rb
01D3	4083	mov     rd, a
01D4	5A02	rlca    rc
01D5	4084	mov     re, a
01D6	0F99	mov     a, 99H
01D7	4303	add     a, rd
01D8	0083	mov     MP1L, a
01D9	0F00	mov     a, 0H
01DA	5304	adc     a, re
01DB	0084	mov     MP1H, a
01DC	2130	call    L0130
01DD	408B	mov     _main_2, a
01DE	212F	call    L012F
01DF	408C	mov     _main_2[1], a
01E0	0F32	mov     a, 32H
01E1	4381	addm    a, rb
01E2	4701	mov     a, rb
01E3	20CA	call    _ADXL345_SPI_Read
01E4	4081	mov     rb, a
01E5	5F02	clr     rc
01E6	7F81	sz      rb.7
01E7	5F82	set     rc
01E8	470B	mov     a, _main_2
01E9	0083	mov     MP1L, a
01EA	470C	mov     a, _main_2[1]
01EB	0084	mov     MP1H, a
01EC	4701	mov     a, rb
01ED	0082	mov     [02H], a
01EE	1483	inc     MP1L
01EF	4702	mov     a, rc
01F0	0082	mov     [02H], a
				;67			}
				;68			/*for(i=0;i<3;i++)
				;69			{
				;70				*ptrAcc[i] = ((*ptrRawData[1+i*2]<<8)&0xFF00) | (*ptrRawData[0+i*2]&0xFF);
				;71				*ptrAcc[i] = *ptrAcc[i] * 4;
				;72			}*/
				;73			/*AccX = ((RawDataX[1]<<8)&0xFF00)|(RawDataX[0]&0xFF);
				;74			AccX = AccX*4;
				;75			AccY = ((RawDataY[1]<<8)&0xFF00)|(RawDataY[0]&0xFF);
				;76			AccY = AccY*4;
				;77			AccZ = ((RawDataZ[1]<<8)&0xFF00)|(RawDataZ[0]&0xFF);
				;78			AccZ = AccZ*4;*/
				;79			
				;80			/*AccX = (((int)ADXL345_SPI_Read(DATAX1)&0xFF00)) | ((int)ADXL345_SPI_Read(DATAX0)&0xFF);
				;81			AccY = (((int)ADXL345_SPI_Read(DATAY1)&0xFF00)) | ((int)ADXL345_SPI_Read(DATAY0)&0xFF);
				;82			AccZ = (((int)ADXL345_SPI_Read(DATAZ1)&0xFF00)) | ((int)ADXL345_SPI_Read(DATAZ0)&0xFF);*/
				;83			
				;84			/*AccX = ((int)ADXL345_SPI_Read(DATAX1)<<8)|(int)ADXL345_SPI_Read(DATAX0);
				;85			AccY = ((int)ADXL345_SPI_Read(DATAY1)<<8)|(int)ADXL345_SPI_Read(DATAY0);
				;86			AccZ = ((int)ADXL345_SPI_Read(DATAZ1)<<8)|(int)ADXL345_SPI_Read(DATAZ0);*/
				;87			
				;88			LCD_Cmd(0x80);  //				_L30:
01F6	0F80	mov     a, 80H
01F7	2132	call    _LCD_Cmd
				;89		 	PrintLCD(AccX);
01F8	4730	mov     a, AccX[0]
01F9	207D	call    _PrintLCD
				;90		  	
				;91		  	LCD_Cmd(0x86);	//01FA	0F86	mov     a, 86H
01FB	2132	call    _LCD_Cmd
				;92		  	PrintLCD(AccY);
01FC	472E	mov     a, AccY[0]
01FD	207D	call    _PrintLCD
				;93			
				;94			LCD_Cmd(0x8d);	//01FE	0F8D	mov     a, 8DH
01FF	2132	call    _LCD_Cmd
				;95		  	PrintLCD(AccZ);
0200	472C	mov     a, AccZ[0]
0201	207D	call    _PrintLCD
				;96	
				;97			deviceID = ADXL345_SPI_Read(0x44);
0202	0F44	mov     a, 44H
0203	20CA	call    _ADXL345_SPI_Read
0204	4080	mov     ra, a
0205	4700	mov     a, ra
0206	40AB	mov     deviceID[0], a
				;98			LCD_Cmd(0xc0);	//0207	0FC0	mov     a, C0H
0208	2132	call    _LCD_Cmd
				;99		  	PrintLCD(deviceID);
0209	472B	mov     a, deviceID[0]
020A	207D	call    _PrintLCD
				;100		}
020B	29C8	jmp     _L29
020C	2A0C	jmp     $
				startup_value:
				@ROMDATA_BASE .SECTION 'CODE'
020D	0018	jmp     L0018
020E	008D	mov     MP2L, a
020F	3637	clr     LVF
0210	3435	clr     T1PE
0211	3233	set     INT2F
0212	00B0	mov     INTC0, a
0213	00AE	mov     PH, a
0214	00AC	mov     __pgc[1], a
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
0215	00BA	mov     SMOD, a
0216	00BC	mov     LVRC, a
0217	00B6	mov     MFI2, a
				;101	}
				;102	//////////////////////////////
				;103	///				;104	//////////////////////////////
				;105	void PinSet(void)
				;106	{
				;107		_wdtc = 0b10101111;//				_PinSet:
				_PinSet:
01A4	0FAF	mov     a, AFH
01A5	00BE	mov     WDTC, a
				;108		_cp0c = 0x00;	//01A6	1F46	clr     CP0C
				;109		_cp1c = 0x00;
01A7	1F47	clr     CP1C
				;110		_scomen = 0;
01A8	367F	clr     SCOMEN
				;111		_smod = 0xe0;//4MHz
01A9	0FE0	mov     a, E0H
01AA	00BA	mov     SMOD, a
				;112		/*_sdis0=0;
				;113		_sdis1=0;
				;114		_simen=1;  
				;115		_simc0=0x42;
				;116		_simc2=0x24;*/
				;117		
				;118		//PAS2=0x10;  //				;119		//PAS3=0x22;  
				;120		//PBS2=0x10;
				;121	
				;122		
				;123		_ifs4=0;
01AB	9F4C	lclr    IFS4
				;124		
				;125		_pac5=0; 	_pac6=1; 	_pac7=0;	CSC=0;//01AD	3693	clr     PAC5
01AE	3313	set     PAC6
01AF	3793	clr     PAC7
01B0	3697	clr     PBC5
				;126		_phc0 =0;   _phc1=0;    _phc2=0; //01B1	342F	clr     PHC0
01B2	34AF	clr     PHC1
01B3	352F	clr     PHC2
				;127		SCK=0;		CS=1;		_pgc = 0x00;   
01B4	3792	clr     PA7
01B5	3296	set     PB5
01B6	1F2B	clr     PGC
01B7	0003	ret
				;128	}
				;129	
				;130	
				;131	//////////////////////////////
				;132	///SPI				;133	//////////////////////////////
				;134	char ADXL345_SPI_Read(char Address)
				;135	{
				_ADXL345_SPI_Read:
				_ADXL345_SPI_Read:
00CA	4087	mov     Address[0], a
				;136	  char ReadData=0;
0108	5F08	clr     ReadData[0]
				;137	  char tempSDO;
				;138	  _SPI_CS(0);
00CB	5F05	clr     bLevel
00CC	5F06	clr     bLevel[1]
00CD	20BE	call    __SPI_CS
				;139	  a=7;
00CE	0F07	mov     a, 7H
00CF	40A5	mov     a[0], a
00D0	5F26	clr     a[1]
				;140	  do{
				;141	    // F-Edge
				;142	    /*LCD_Cmd(0x80);
				;143	    PrintLCD(a);*/
				;144	    _SPI_SCL(1);
				L00D1:
00D1	0F01	mov     a, 1H
00D2	4085	mov     bLevel, a
00D3	5F06	clr     bLevel[1]
00D4	20B4	call    __SPI_SCL
				;145	    SDO = 0x1 & ((0x80 | Address) >> a);
00D5	4707	mov     a, Address[0]
00D6	4081	mov     rb, a
00D7	5F02	clr     rc
00D8	3F85	sz      ACC.7
00D9	5F82	set     rc
00DA	0F00	mov     a, 0H
00DB	4582	orm     a, rc
00DC	0F80	mov     a, 80H
00DD	4581	orm     a, rb
00DE	5425	inca    a[0]
00DF	28E5	jmp     L00E5
				L00E0:
00E0	340A	clr     C
00E1	7F82	sz      rc.7
00E2	300A	set     C
00E3	5B82	rrc     rc
00E4	5B81	rrc     rb
				L00E5:
00E5	1785	sdz     ACC
00E6	28E0	jmp     L00E0
00E7	0F01	mov     a, 1H
00E8	4681	andm    a, rb
00E9	5101	swapa   rb
00EA	1885	rl      ACC
00EB	0EE0	and     a, E0H
00EC	4081	mov     rb, a
00ED	3692	clr     PA5
00EE	4701	mov     a, rb
00EF	0592	orm     a, PA
				;146	    _SPI_SCL(0);
00F0	5F05	clr     bLevel
00F1	5F06	clr     bLevel[1]
00F2	20B4	call    __SPI_SCL
				;147	    a--;
00F3	0FFF	mov     a, FFH
00F4	4325	add     a, a[0]
00F5	4081	mov     rb, a
00F6	0FFF	mov     a, FFH
00F7	5326	adc     a, a[1]
00F8	4082	mov     rc, a
00F9	4701	mov     a, rb
00FA	40A5	mov     a[0], a
00FB	4702	mov     a, rc
00FC	40A6	mov     a[1], a
				;148	  }while(a!=0);
00FD	4701	mov     a, rb
00FE	4502	or      a, rc
00FF	390A	snz     Z
0100	28D1	jmp     L00D1
				;149	 
				;150	  //===========================
				;151	  _SPI_SCL(1);
0101	0F01	mov     a, 1H
0102	4085	mov     bLevel, a
0103	5F06	clr     bLevel[1]
0104	20B4	call    __SPI_SCL
				;152	  //===========================
				;153	  a=7;
0105	0F07	mov     a, 7H
0106	40A5	mov     a[0], a
0107	5F26	clr     a[1]
				;154	  do{
				;155	    // R-Edge
				;156	    _SPI_SCL(0);
				L0109:
0109	5F05	clr     bLevel
010A	5F06	clr     bLevel[1]
010B	20B4	call    __SPI_SCL
				;157	    _SPI_SCL(1);
010C	0F01	mov     a, 1H
010D	4085	mov     bLevel, a
010E	5F06	clr     bLevel[1]
010F	20B4	call    __SPI_SCL
				;158	    tempSDO = SDI; // Read bit
0110	5F01	clr     rb
0111	3F12	sz      PA6
0112	5481	inc     rb
				;159	    ReadData |= tempSDO << a;
0113	5F02	clr     rc
0114	5425	inca    a[0]
0115	2919	jmp     L0119
				L0116:
0116	340A	clr     C
0117	5A81	rlc     rb
0118	5A82	rlc     rc
				L0119:
0119	1785	sdz     ACC
011A	2916	jmp     L0116
011B	4701	mov     a, rb
011C	4588	orm     a, ReadData[0]
				;160	    a--;
011D	0FFF	mov     a, FFH
011E	4325	add     a, a[0]
011F	4081	mov     rb, a
0120	0FFF	mov     a, FFH
0121	5326	adc     a, a[1]
0122	4082	mov     rc, a
0123	4701	mov     a, rb
0124	40A5	mov     a[0], a
0125	4702	mov     a, rc
0126	40A6	mov     a[1], a
				;161	  }while(a>=0);
0127	7B82	snz     rc.7
0128	2909	jmp     L0109
				;162	 
				;163	  _SPI_CS(1);
0129	0F01	mov     a, 1H
012A	4085	mov     bLevel, a
012B	5F06	clr     bLevel[1]
012C	20BE	call    __SPI_CS
				;164	  return ReadData & 0xFF;
				;165	}
012D	4708	mov     a, ReadData[0]
012E	0003	ret
				L012F:
012F	1483	inc     MP1L
				L0130:
0130	0702	mov     a, [02H]
0131	0003	ret
				;166	
				;167	//////////////////////////////
				;168	///LCD				;169	//////////////////////////////
				;170	void PrintLCD(unsigned char data)
				;171	{
				_PrintLCD:
				_PrintLCD:
007D	4080	mov     ra, a
007E	408A	mov     data[0], a
				;172		LCD_Senddata((data/100)%10+0x30);
007F	5F08	clr     Address
0080	4700	mov     a, ra
0081	4085	mov     bLevel, a
0082	0F64	mov     a, 64H
0083	4086	mov     bLevel[1], a
0084	2064	call    L0064
0085	4705	mov     a, bLevel
0086	4080	mov     ra, a
0087	5F08	clr     Address
0088	4700	mov     a, ra
0089	4085	mov     bLevel, a
008A	0F0A	mov     a, AH
008B	4086	mov     bLevel[1], a
008C	2064	call    L0064
008D	4707	mov     a, data
008E	4080	mov     ra, a
008F	0F30	mov     a, 30H
0090	4380	addm    a, ra
0091	4700	mov     a, ra
0092	2057	call    _LCD_Senddata
				;173		LCD_Senddata((data/10)%10+0x30);
0093	5F08	clr     Address
0094	470A	mov     a, data[0]
0095	4085	mov     bLevel, a
0096	0F0A	mov     a, AH
0097	4086	mov     bLevel[1], a
0098	2064	call    L0064
0099	4705	mov     a, bLevel
009A	4080	mov     ra, a
009B	5F08	clr     Address
009C	4700	mov     a, ra
009D	4085	mov     bLevel, a
009E	0F0A	mov     a, AH
009F	4086	mov     bLevel[1], a
00A0	2064	call    L0064
00A1	4707	mov     a, data
00A2	4080	mov     ra, a
00A3	0F30	mov     a, 30H
00A4	4380	addm    a, ra
00A5	4700	mov     a, ra
00A6	2057	call    _LCD_Senddata
				;174		LCD_Senddata((data/1)%10+0x30);
00A7	5F08	clr     Address
00A8	470A	mov     a, data[0]
00A9	4085	mov     bLevel, a
00AA	0F0A	mov     a, AH
00AB	4086	mov     bLevel[1], a
00AC	2064	call    L0064
00AD	4707	mov     a, data
00AE	4080	mov     ra, a
00AF	0F30	mov     a, 30H
00B0	4380	addm    a, ra
00B1	4700	mov     a, ra
00B2	2057	call    _LCD_Senddata
00B3	0003	ret
				;175	}
				;176	
				;177	//////////////////////////////
				;178	///Delay100us				;179	//////////////////////////////
				;180	void Delay100us(short del)						//				;181	{	unsigned short k,l;									//@fSYS=8MH,				_Delay100us:
				_Delay100us:
003F	4705	mov     a, del[0]
0040	4083	mov     rd, a
0041	4706	mov     a, del[1]
0042	4084	mov     re, a
				;182		for(k=0;k<del;k++)
0043	5F01	clr     rb
0044	5F02	clr     rc
				_L3:
0045	4701	mov     a, rb
0046	4203	sub     a, rd
0047	4702	mov     a, rc
0048	5204	sbc     a, re
0049	3F0A	sz      CZ
004A	2856	jmp     _L2
004B	5F00	clr     ra
0052	5481	inc     rb
0053	3D0A	sz      Z
0054	5482	inc     rc
0055	2845	jmp     _L3
				_L2:
0056	0003	ret
				;183			for(l=0;l<=25;l++)GCC_NOP();
				_L6:
004C	0000	nop
004D	5480	inc     ra
004E	4700	mov     a, ra
004F	0A1A	sub     a, 1AH
0050	390A	snz     Z
0051	284C	jmp     _L6
				;184	}	
				;185	
				;186	//////////////////////////////
				;187	///CS				;188	//////////////////////////////
				;189	void _SPI_CS(unsigned short isSelect)
				;190	{
				;191	    CS=isSelect;
				__SPI_CS:
				__SPI_CS:
00BE	4705	mov     a, isSelect[0]
00BF	0E01	and     a, 1H
00C0	4080	mov     ra, a
00C1	5100	swapa   ra
00C2	1885	rl      ACC
00C3	0EE0	and     a, E0H
00C4	4080	mov     ra, a
00C5	3696	clr     PB5
00C6	4700	mov     a, ra
00C7	0596	orm     a, PB
				;192	    _nop();
00C8	0000	nop
00C9	0003	ret
				;193	}
				;194	
				;195	//////////////////////////////
				;196	///SCL				;197	//////////////////////////////
				;198	void _SPI_SCL(unsigned short bLevel)
				;199	{
				;200	    SCK=bLevel;
				__SPI_SCL:
				__SPI_SCL:
00B4	4705	mov     a, bLevel[0]
00B5	4080	mov     ra, a
00B6	5B80	rrc     ra
00B7	5F00	clr     ra
00B8	5B80	rrc     ra
00B9	3792	clr     PA7
00BA	4700	mov     a, ra
00BB	0592	orm     a, PA
				;201	    _nop();
00BC	0000	nop
00BD	0003	ret
				;202	}
				;203	
				;204	//////////////////////////////
				;205	///SPI				;206	//////////////////////////////
				;207	void ADXL345_SPI_Write(char Address, char WriteData)
				;208	{
				_ADXL345_SPI_Write:
				_ADXL345_SPI_Write:
014A	4088	mov     Address[0], a
				;209	  _SPI_CS(0);
014B	5F05	clr     bLevel
014C	5F06	clr     bLevel[1]
014D	20BE	call    __SPI_CS
				;210	  for(b=7;b>=0;b--)
014E	0F07	mov     a, 7H
014F	40A7	mov     b[0], a
0150	5F28	clr     b[1]
				L0151:
0151	7FA8	sz      b[1].7
0152	2977	jmp     L0177
0172	0FFF	mov     a, FFH
0173	43A7	addm    a, b[0]
0174	0FFF	mov     a, FFH
0175	53A8	adcm    a, b[1]
0176	2951	jmp     L0151
				;211	  {
				;212	    // F-Edge
				;213	    _SPI_SCL(1);
0153	0F01	mov     a, 1H
0154	4085	mov     bLevel, a
0155	5F06	clr     bLevel[1]
0156	20B4	call    __SPI_SCL
				;214	    SDI = 0x1 & ((0x7F & Address) >> b);
0157	4708	mov     a, Address[0]
0158	4081	mov     rb, a
0159	7781	clr     rb.7
015A	5F02	clr     rc
015B	7F81	sz      rb.7
015C	5F82	set     rc
015D	5427	inca    b[0]
015E	2964	jmp     L0164
				L015F:
015F	340A	clr     C
0160	7F82	sz      rc.7
0161	300A	set     C
0162	5B82	rrc     rc
0163	5B81	rrc     rb
				L0164:
0164	1785	sdz     ACC
0165	295F	jmp     L015F
0166	0F01	mov     a, 1H
0167	4681	andm    a, rb
0168	5901	rra     rb
0169	1985	rr      ACC
016A	0EC0	and     a, C0H
016B	4081	mov     rb, a
016C	3712	clr     PA6
016D	4701	mov     a, rb
016E	0592	orm     a, PA
				;215	    _SPI_SCL(0);
016F	5F05	clr     bLevel
0170	5F06	clr     bLevel[1]
0171	20B4	call    __SPI_SCL
				;216	  }
				;217	  
				;218	  for(b=7;b>=0;b--)
				L0177:
0177	0F07	mov     a, 7H
0178	40A7	mov     b[0], a
0179	5F28	clr     b[1]
				L017A:
017A	7FA8	sz      b[1].7
017B	299F	jmp     L019F
019A	0FFF	mov     a, FFH
019B	43A7	addm    a, b[0]
019C	0FFF	mov     a, FFH
019D	53A8	adcm    a, b[1]
019E	297A	jmp     L017A
				;219	  {
				;220	    // F-Edge
				;221	    _SPI_SCL(1);
017C	0F01	mov     a, 1H
017D	4085	mov     bLevel, a
017E	5F06	clr     bLevel[1]
017F	20B4	call    __SPI_SCL
				;222	    SDI = 0x1 & ((WriteData) >> b);
0180	4707	mov     a, WriteData[0]
0181	4081	mov     rb, a
0182	5F02	clr     rc
0183	3F85	sz      ACC.7
0184	5F82	set     rc
0185	5427	inca    b[0]
0186	298C	jmp     L018C
				L0187:
0187	340A	clr     C
0188	7F82	sz      rc.7
0189	300A	set     C
018A	5B82	rrc     rc
018B	5B81	rrc     rb
				L018C:
018C	1785	sdz     ACC
018D	2987	jmp     L0187
018E	0F01	mov     a, 1H
018F	4681	andm    a, rb
0190	5901	rra     rb
0191	1985	rr      ACC
0192	0EC0	and     a, C0H
0193	4081	mov     rb, a
0194	3712	clr     PA6
0195	4701	mov     a, rb
0196	0592	orm     a, PA
				;223	    _SPI_SCL(0);
0197	5F05	clr     bLevel
0198	5F06	clr     bLevel[1]
0199	20B4	call    __SPI_SCL
				;224	  }
				;225	
				;226	  _SPI_CS(1);
				L019F:
019F	0F01	mov     a, 1H
01A0	4085	mov     bLevel, a
01A1	5F06	clr     bLevel[1]
01A2	20BE	call    __SPI_CS
01A3	0003	ret
				;227	}
				;228	
				;229	//---				;230	void LCD_Cmd(unsigned char data)
				;231	{
				_LCD_Cmd:
				_LCD_Cmd:
0132	4080	mov     ra, a
0133	4087	mov     data[0], a
				;232	    DATA_BUS = data;  //0134	4700	mov     a, ra
0135	00AA	mov     PG, a
				;233	    RS=0; RW=0; EN=1; //0136	342E	clr     PH0
0137	34AE	clr     PH1
0138	312E	set     PH2
				;234	    Delay100us(20);
0139	0F14	mov     a, 14H
013A	4085	mov     bLevel, a
013B	5F06	clr     bLevel[1]
013C	203F	call    _Delay100us
				;235	    EN=0;           //013D	352E	clr     PH2
013E	0003	ret
				;236	}
				;237	//---				;238	void LCD_Senddata(unsigned char data)
				;239	{
				_LCD_Senddata:
				_LCD_Senddata:
0057	4080	mov     ra, a
0058	4087	mov     data[0], a
				;240	    DATA_BUS = data;  //0059	4700	mov     a, ra
005A	00AA	mov     PG, a
				;241	    RS=1; RW=0; EN=1; //005B	302E	set     PH0
005C	34AE	clr     PH1
005D	312E	set     PH2
				;242		Delay100us(20);
005E	0F14	mov     a, 14H
005F	4085	mov     bLevel, a
0060	5F06	clr     bLevel[1]
0061	203F	call    _Delay100us
				;243	    EN=0;           //0062	352E	clr     PH2
0063	0003	ret
				L0064:
0064	5F07	clr     data[0]
0065	0F08	mov     a, 8H
0066	4089	mov     Address[1], a
				L0067:
0067	340A	clr     C
0068	5A85	rlc     bLevel
0069	5A87	rlc     data[0]
006A	4707	mov     a, data[0]
006B	4206	sub     a, bLevel[1]
006C	380A	snz     C
006D	2872	jmp     L0072
006E	4707	mov     a, data[0]
006F	4206	sub     a, bLevel[1]
0070	4087	mov     data[0], a
0071	5485	inc     bLevel
				L0072:
0072	5789	sdz     Address[1]
0073	2867	jmp     L0067
0074	7C08	sz      Address.0
0075	4187	cpl     data[0]
0076	7C08	sz      Address.0
0077	5487	inc     data[0]
0078	7C88	sz      Address.1
0079	4185	cpl     bLevel
007A	7C88	sz      Address.1
007B	5485	inc     bLevel
007C	0003	ret
				;244	}
				;245	//---LCD				;246	void LCD_Reset(void)
				;247	{
				;248	    LCD_Cmd(0b00111000);//8bit				_LCD_Reset:
				_LCD_Reset:
013F	0F38	mov     a, 38H
0140	2132	call    _LCD_Cmd
				;249	                        //bit4:DL=1,8bit				;250	                        //bit3:N=1,				;251	                        //bit2:F=0,5*7				;252	    LCD_Cmd(0b00001100);//0141	0F0C	mov     a, CH
0142	2132	call    _LCD_Cmd
				;253	                        //bit2:D=1,				;254	                        //bit1:C=0,				;255	    LCD_Cmd(0b00000110);//0143	0F06	mov     a, 6H
0144	2132	call    _LCD_Cmd
				;256	                        //bit1:I/D=1,				;257	                        //bit0:S=0,				;258	    LCD_Cmd(0b00000001); //0145	0F01	mov     a, 1H
0146	2132	call    _LCD_Cmd
				;259	    LCD_Cmd(0b00000010); //0147	0F02	mov     a, 2H
0148	2132	call    _LCD_Cmd
0149	0003	ret
				;260	}
				;file C:\Users\IIIT\Desktop\ADXL345\try1\ADXL345_SPI\startup1_l.asm
				;1	;;--------------------------------------------------------------;;
				;2	;;    This file is part of the Holtek C Compiler V3 package     ;;
				;3	;;    For the initialization of static linkage variables        ;;
				;4	;;    Copyright (C) 2017 Holtek Semiconductor Inc.              ;;
				;5	;;    Version: 1.07 (Above IDE3000 V7.94)                       ;;
				;6	;;    Date:    2017/03/06                                        ;;
				;7	;;--------------------------------------------------------------;;
				;8	
				;9	acc equ [05h]
				;10	tblp equ [07h]
				;11	tblh equ [08h]
				;12	;;tbhp equ [09h] 
				;13	r0 equ [00h]
				;14	mp0 equ [01h]
				;15	r1 equ [02h]
				;16	mp1l equ [03h]
				;17	mp1h equ [04h]
				;18	z equ [0ah].2
				;19	c equ [0ah].0
				;20	
				;21	ifndef tbhp
				;22	tbhp equ [09h]
				;23	endif
				;24	 
				;25	extern startup_value_1:near
				;26	
				;27	@start .section 'code'
				;28	begin_startup_value:
				;29	  mov a,low (offset startup_value_1) 
				begin_startup_value:
				@start .SECTION 'CODE'
				_main_startup1:
				@start .SECTION 'CODE'
0002	0F0C	mov     a, CH
				;30	  mov tblp,a
0003	0087	mov     TBLP, a
				;31	  mov a,high (offset startup_value_1) 
0004	0F02	mov     a, 2H
				;32	  mov tbhp,a
0005	0089	mov     TBHP, a
				;33	next_table:
				;34	  ;CLR WDT
				;35	  inc tblp
				next_table:
0006	1487	inc     TBLP
				;36	  sz z
0007	3D0A	sz      Z
				;37	  inc tbhp
0008	1489	inc     TBHP
				;38	ifdef USE_TABRDC
				;39	  tabrdc mp0
				;40	else
				;41	  tabrd mp0
0009	1D01	tabrd   MP0
				;42	endif
				;43	  sz mp0
000A	1081	sz      MP0
				;44	  jmp read_data
000B	280D	jmp     read_data
				;45	  jmp startupend1
000C	2822	jmp     startupend1
				;46	read_data:
				;47	  inc tblp
				read_data:
000D	1487	inc     TBLP
				;48	  sz z
000E	3D0A	sz      Z
				;49	  inc tbhp
000F	1489	inc     TBHP
				;50	ifdef USE_TABRDC
				;51	  tabrdc mp1l
				;52	else
				;53	  tabrd mp1l
0010	1D03	tabrd   MP1L
				;54	endif
				;55	  mov a,tblh
0011	0708	mov     a, TBLH
				;56	  mov mp1h,a
0012	0084	mov     MP1H, a
				;57	next_data:
				;58	  inc tblp
				next_data:
0013	1487	inc     TBLP
				;59	  sz z
0014	3D0A	sz      Z
				;60	  inc tbhp
0015	1489	inc     TBHP
				;61	ifdef USE_TABRDC
				;62	  tabrdc acc
				;63	else
				;64	  tabrd acc
0016	1D05	tabrd   ACC
				;65	endif
				;66	  mov r1,a
0017	0082	mov     [02H], a
				;67	  sdz mp0
				L0018:
0018	1781	sdz     MP0
				;68	  jmp $+2
0019	281B	jmp     L001B
				;69	  jmp next_table
001A	2806	jmp     next_table
				;70	  inc mp1l
				L001B:
001B	1483	inc     MP1L
				;71	  mov a,tblh
001C	0708	mov     a, TBLH
				;72	  mov r1,a
001D	0082	mov     [02H], a
				;73	  inc mp1l
001E	1483	inc     MP1L
				;74	  sdz mp0
001F	1781	sdz     MP0
				;75	  jmp next_data
0020	2813	jmp     next_data
				;76	  jmp next_table
0021	2806	jmp     next_table
				;77	
				;78	;end_startup_value:
				;79	
				;80	startupend1:
				;81	ifndef Disable_Bit_Initial
				;82		MOV A,high  bitdatasec1_start
				startupend1:
0022	0F00	mov     a, 0H
				;83		MOV mp1h,a
0023	0084	mov     MP1H, a
				;84		MOV A,offset bitdatasec1_end
0024	0F80	mov     a, 80H
				;85		mov mp1l,A
0025	0083	mov     MP1L, a
				;86		dec mp1l
0026	1583	dec     MP1L
				;87		clr z
0027	350A	clr     Z
				;88		sub a,offset bitdatasec1_start
0028	0A80	sub     a, 80H
				;89		sz z
0029	3D0A	sz      Z
				;90		jmp startupend2
002A	282F	jmp     startupend2
				;91	L0005:
				;92		set r1
				L0005:
002B	1F82	set     [02H]
				;93		dec mp1l
002C	1583	dec     MP1L
				;94		sdz  acc
002D	1785	sdz     ACC
				;95		jmp L0005
002E	282B	jmp     L0005
				;96	
				;97	startupend2:
				;98		MOV A,high  bitdatasec0_start
				startupend2:
002F	0F00	mov     a, 0H
				;99		MOV mp1h,a
0030	0084	mov     MP1H, a
				;100		MOV A,offset bitdatasec0_end
0031	0F80	mov     a, 80H
				;101		mov mp1l,A
0032	0083	mov     MP1L, a
				;102		dec mp1l
0033	1583	dec     MP1L
				;103		clr z
0034	350A	clr     Z
				;104		sub a,offset bitdatasec0_start
0035	0A80	sub     a, 80H
				;105		sz  z
0036	3D0A	sz      Z
				;106		jmp startupend3
0037	283C	jmp     startupend3
				;107	L0006:
				;108		clr r1
				L0006:
0038	1F02	clr     [02H]
				;109		dec mp1l
0039	1583	dec     MP1L
				;110		sdz  acc
003A	1785	sdz     ACC
				;111		jmp L0006
003B	2838	jmp     L0006
				;112	startupend3:
				;113	endif		
				;114	   
				;115	@ROMDATA_BASE .SECTION com_l 'CODE'  
				;116	startup_value:
				;117	;;linker range the initial value table here
				;118	
				;119	@BITDATASEC1 .SECTION com_l 'DATA'  
				;120	bitdatasec1_start:
				;121	
				;122	@BITDATASEC1 .SECTION com_e 'DATA'  
				;123	bitdatasec1_end:
				;124	
				;125	@BITDATASEC .SECTION com_l 'DATA'  
				;126	bitdatasec0_start:
				;127	
				;128	@BITDATASEC .SECTION com_e 'DATA'  
				;129	bitdatasec0_end:
				data .SECTION 'DATA'
				__pa DB DUP (?) ; __pa
				__pac DB DUP (?) ; __pac
				__pb DB DUP (?) ; __pb
				__pbc DB DUP (?) ; __pbc
				__pg DB DUP (?) ; __pg
				__pgc DB DUP (?) ; __pgc
				__ph DB DUP (?) ; __ph
				__phc DB DUP (?) ; __phc
				__smod DB DUP (?) ; __smod
				__wdtc DB DUP (?) ; __wdtc
				__cp0c DB DUP (?) ; __cp0c
				__cp1c DB DUP (?) ; __cp1c
				__scomc DB DUP (?) ; __scomc
				ra DB DUP (?)
				rb DB DUP (?)
				rc DB DUP (?)
				rd DB DUP (?)
				re DB DUP (?)
				bLevel DB 2 DUP (?) ; bLevel
				data DB DUP (?) ; data
				Address DB DUP (?) ; Address
				data DB DUP (?) ; data
				_main_2 DB DUP (?)
				DATAZ1 DB DUP (?) ; DATAZ1
				DATAZ0 DB DUP (?) ; DATAZ0
				DATAY1 DB DUP (?) ; DATAY1
				DATAY0 DB DUP (?) ; DATAY0
				DATAX1 DB DUP (?) ; DATAX1
				DATAX0 DB DUP (?) ; DATAX0
				ptrAcc DB DUP (?) ; ptrAcc
				ptrRawData DB DUP (?) ; ptrRawData
				a DB 2 DUP (?) ; a
				b DB 2 DUP (?) ; b
				i DB 2 DUP (?) ; i
				deviceID DB DUP (?) ; deviceID
				AccZ DB 2 DUP (?) ; AccZ
				AccY DB 2 DUP (?) ; AccY
				AccX DB 2 DUP (?) ; AccX
				RawDataZ DB DUP (?) ; RawDataZ
				RawDataY DB DUP (?) ; RawDataY
				RawDataX DB DUP (?) ; RawDataX
				__ifs4 DB DUP (?) ; __ifs4
